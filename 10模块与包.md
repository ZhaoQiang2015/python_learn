# 模块与包
##1. 构建一个模块的层级包
- 在文件系统上组织代码，确保每个目录都定义了一个`__init__.py`文件。此文件的目的是要包含不同运行级别的包可选的初始化代码。
- 大多时候让`__init__.py`空着就可以，但有时可包含代码，
##2. 控制模块被全部导入的内容
- 当希望明确一个模块中可以被导出的内容时，在模块中定义一个变量`__all__`，来明确地列出需要导出的内容。
- 如果将`__all__`定义成一个空列表，没有东西将被导入。如果`__all__`包含未定义的名字，在导入时引起`AttributeError`。
##3. 使用相对路径名导入包中子模块
- 在包内，既可以使用相对路径也可以使用绝对路径来导入。
- import语句的`.`和`..`分别指代当前目录和上一级目录。
- **相对导入不能到定义包的目录之外。即，使用点的这种模式从不是包的目录中导入将会引发错误。**
##4. 将模块分割成多个文件
- 程序模块可以通过变成包来分割成多个独立的文件。
- 当一个模块被分割，需要特别注意交叉引用的文件名。
- 延迟加载技术的主要缺点是继承和类型检查可能会中断。
##5. 利用命名空间导入目录分散的代码
- 
-
##6. 重新加载模块
- 使用`imp.reload()`来重新加载先前加载的模块。
- **在生产环境中可能需要避免重新加载模块。**
##7. 运行目录或压缩文件
- 创建一个目录或zip文件并添加`__main__.py`文件来将一个更大的Python应用打包是可行的。这和作为标准库被安装到Python库的代码包有一点区别。
##8. 读取位于包中的数据文件
- 使用`pkgutil.get_data()`函数。
##9. 将文件夹加入到sys.path
- 有两种常用方式将新目录加入到`sys.path`。
1.使用`PYTHONPATH`环境变量来添加。
2.创建一个`.pth`文件，将目录列举出来。这个`.pth`文件需要放在Python的site-packages目录中。
3.使用`sys.path.insert()`。这种方法存在问题，它将目录硬编码到代码中。移植性不好。
- `site-packages`目录是第三方包和模块安装的目录。
##10. 通过字符串名导入模块
- 使用`importlib.import_module()`函数。
- 它返回生成的模块对象。
##11. 通过钩子远程加载模块
- ...
- ...
- ...
##12. 安装私有的包
- Python有一个用户安装目录，要强制在这个目录中安装包，可以使用安装选项`--user`
##13. 创建新的Python环境
- 使用`pyvenv`
##14. 分发包
- 发布一个包，首先需要编写一个`setup.py`文件，然后编写`MANIFEST.in`文件，列出所有在包中需要包含进来的非源码文件。
